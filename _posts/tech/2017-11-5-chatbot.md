---
title:  "基于Rasa_NLU的微信chatbot"
layout: blog
tech: true
background-image: http://static.zybuluo.com/sixijinling/an3ms22v79lqj34nkolbbihi/chatbot.png
istop: true
date:   2017-11-05
category: 技术
tags:
- chatbot
- NLP
description: "Rasa_NLU + Rasa_Core + wxpy = 微信智能聊天机器人"
---
[TOC]

# 重要资料

- 本项目的github地址：[Rasa_wechat][4]
- [wxpy文档][6]
- [Rasa_NLU官方文档][16]
- [Rasa_Core官方文档][22]

# 研究背景

![聊天机器人系统框图][1]

- 老式chatbot基于大量规则库，不好维护。ps: 一个比较有意思例子是[伪春菜][2]。
- 主流架构为”NLU自然语言理解+DM对话管理+NLG自然语言生成”，也就是上图展示的除ASR和TTS的部分。
    - NLU负责基础自然语言处理，主要目标是**意图识别**与**实体识别**；
    - DM负责**对话状态维护**、**数据库查询**等；
    - NLG负责生成**交互的自然语言**。
- 机器学习尤其是深度学习在不断改进NLU、DM和NLG，乃至对整个架构的颠覆。
    - 每一个模块都换成DL模型，甚至再加入User Simulator做强化学习，进行端到端的训练；
    - Memory Networks：将整个知识库都encode在一个复杂的深度网络中，然后再和encode过的问题结合起来decode生成答案。这个工作最多还是应用在机器阅读理解上，在垂直领域任务导向的chatbot上的成功应用还有待观察。

# 步入正题

这里，我们基于`Rasa_NLU`和`Rasa_Core`来搭建chatbot，利用微信的python接口`wxpy`来实现微信端的交互，其流程图（图片来自Rasa_Core官网）如下：

![流程图][3]

最上面的`Rasa_NLU`就是最开始讲到的负责**自然语言理解**的部分，而最下面的`Rasa_Core`则是在得到了`intent`和`entities`之后负责生成`next_action`以及自然语言的回复。最左边的一问一答则由`wxpy`来完成监听消息和发送消息的任务。

大概的流程用代码表示的话：

```python
#输入
input_string=""
#意图识别
intent_object=intent(input_string)
#回复生成
response=policy(intent_object)
#返回用户
print(response)
```

这里先贴上本项目的github地址：[Rasa_wechat][4]。
从易到难，由浅入深，我们从微信接口说起，即`输入`和`返回用户`的过程。

## wxpy——用Python玩微信

[wxpy][5]可用来实现各种微信个人号的自动化操作。具体的使用参见[wxpy文档][6]，应用实例可参考[connector-wechat-bot][7]。这里其实只用了收发消息的接口，“智能”的部分交由后文的Rasa_Core完成。

```
from wxpy import *
# 初始化机器人，扫码登陆
bot = Bot(console_qr=True, cache_path=True)
```
由于代码部署在服务器上，不能通过终端打开图片，参数`console_qr=True`表示在终端内显示二维码；`cache_path=True`启用缓存，来保存自己的登录状态。

自己加自己好友方便以后做测试：
```
# 在 Web 微信中把自己加为好友
bot.self.add()
bot.self.accept()

# 发送消息给自己
bot.self.send('能收到吗？')
```

wxpy提供了注册消息的方法，可以将各种类型的消息注册并自定义处理方式。
```
@bot.register(bot.self, except_self=False)
def reply_self(msg):
    ans = agent.handle_message(msg.text)
```
```
from rasa_core.agent import Agent
from rasa_core.interpreter import RasaNLUInterpreter

# 自己训练好的NLU模型路径
nlu_model_path = '/home/luoling/rasa_nlu_chi/models/rasa_nlu_test/model_20171013-153447'
# agent = 自己训练好的policy模型 + NLU模型作为interpreter
agent = Agent.load("../babi/models/policy/current", interpreter=RasaNLUInterpreter(nlu_model_path))
```

重头戏分别是负责语言理解的`nlu_model`和负责对话管理的`agent`，将在下面两部分展开介绍。

最后别忘了让程序保持运行：
```
# 进入 Python 命令行、让程序保持运行
embed()
```

## 自然语言理解（NLU）

针对用户的问题，NLU模块的任务是：

1. 意图识别 (Intent)：在**句子级别**进行分类，明确意图；
2. 实体识别 (Entity)：在**词级别**找出用户问题中的**关键实体**，进行实体槽填充(Slot Filling)。

举个例子，用户问“我想吃羊肉泡馍”，NLU模块就可以识别出用户的意图是“寻找餐馆”，而关键实体是“羊肉泡馍”。有了意图和关键实体，就方便了后面对话管理模块进行后端数据库的查询或是有缺失信息而来继续多轮对话补全其它缺失的实体槽。

已有的NLU工具，大多是以服务的方式，通过调用远程http的restful API来对目标语句进行解析完成上述两个任务，例如Google的API.ai, Microsoft的Luis.ai, Facebook的Wit.ai等。

事实上，申请到这类API的话[用几行代码即可完成一个chatbot][8]，亦可参考[使用图灵机器人和api.ai相关接口][9]。而我们这里要用的[Rasa_NLU][10]以及后面介绍的[Rasa_Core][11]则是[rasa.ai][12]提供的开源工具，支持Python 2和3，可以本地部署，自己针对实际需求训练和调整模型。此外，如果想从零开始动手实现NLU，推荐阅读[Do-it-yourself NLP for bot developers][13]。

遗憾的是，[Rasa_NLU][14]官方目前只支持英语和德语，因此这里参考[基于中文的Rasa NLU][15]来训练自己的中文NLU模型，不过仍然建议认真阅读[Rasa_NLU官方文档][16]。

### 语料获取和预处理

可参考这里假设已经根据[用Rasa NLU构建自己的中文NLU系统][17]这篇博文对自己的数据进行了处理，提供训练好的NLU模型

### MITIE

[MITIE][20]（MIT Information Extraction）是MIT的 NLP 团队发布的一个信息抽取库和工具。目前包含：

- 命名实体抽取（Named-Entity-Recognize，NER）
- 二元关系检测功能（Bianry relation detection）

另外也提供了训练自定义抽取器和关系检测器的工具。

- distributional word embeddings
- Structural Support Vector Machines

尽管 MITIE 是 C++ 写的，但它也提供了其他语言的调用 API 。这里编译成动态库再用 Python 调用就行了，很方便。
```
MITIE\mitielib>mkdir build
MITIE\mitielib>cd build
MITIE\mitielib\build>cmake ..
MITIE\mitielib\build>cmake --build . --config Release --target install
```
##### 分词：jieba

先安装jieba分词，：
```
$ pip install jieba
# 将一个语料文件分词，以空格为分隔符
$ python -m jieba -d " " ./test > ./test_cut
```
把所有分好词的语料文件放在同一个文件路径下。接下来我们要训练MITIE模型。

##### 词向量：wordprep

主要是要**训练所有词向量特征**，后面的实名实体模型和关系模型都是建立在它的基础上，MITIE 给我们提供了工具完成上述操作，我们可以用 cmake 生成vs项目，但一般我们没有必要改动到代码，直接使用 cmake 构建一下就可直接使用。主要操作有

```
\MITIE\tools\wordrep>mkdir build
\MITIE\tools\wordrep>cd build
\MITIE\tools\wordrep\build>cmake ..
\MITIE\tools\wordrep\build>cmake --build . --config Release
```

训练模型得到total_word_feature_extractor.dat的过程异常漫长，也很占内存，建议在服务器上完成。

```
$ ./wordrep -e /path/to/your/folder_of_cutted_text_files
```

用nohup跑MITIE的wordrep

再一个是需要收集大量的词汇，可以通过维基百科和百度百科收集，类似处理可以参加前面的文章 《如何使用中文维基百科语料》。

下载并处理中文维基语料，加上联通常见问题

可视化编辑语料[rasa-nlu-trainer][19]
Entities are specified with a start and end value, which together make a python style range to apply to the string, e.g. in the example below, with `text="show me chinese restaurants"`, then `text[8:15] == 'chinese'`. Entities can span multiple words, and in fact the value field does not have to correspond exactly to the substring in your example. That way you can **map syonyms, or misspellings, to the same value**.

也支持markdown训练语料


For [MITIE][20] models this is just a score, which might be greater than 1.
You can use this to do some error handling in your chatbot (ex: asking the user again if the confidence is low) and it’s also helpful for prioritising which intents need more training data.

### 流程

在`sample_configs/config_jieba_mitie_sklearn.json`配置的Rasa NLU的工作流水线（pipeline）如下：

```
# MITIE+Jieba+sklearn:
[“nlp_mitie”, “tokenizer_jieba”, “ner_mitie”, “ner_synonyms”, “intent_featurizer_mitie”, “intent_classifier_sklearn”]
```
- `nlp_mitie`初始化[MITIE][20]；
- `tokenizer_jieba`用jieba来做分词；
- `ner_mitie`和`ner_synonyms`做实体识别；
- `intent_featurizer_mitie`为意图识别做特征提取；
- `intent_classifier_sklearn`使用sklearn做意图识别的分类。

根据config训练NLU模型：
```
$ python -m rasa_nlu.train -c sample_configs/config_jieba_mitie_sklearn.json
```
这样就会生成一个类似`model_20171013-153447`的文件在 /models/your_project_name 的文件夹里。项目文件中提供训练好的NLU模型：`/rasa_nlu_chi/models/rasa_nlu_test/model_20171013-153447`

### 测试效果

#### 启动rasa_nlu的HTTP服务

```
$ curl -XPOST localhost:5000/parse -d '{"q":"我发烧了该吃什么药？", "project": "rasa_nlu_test", "model": "model_20170921-170911"}' | python -mjson.tool
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   652    0   552  100   100    157     28  0:00:03  0:00:03 --:--:--   157
{
    "entities": [
        {
            "end": 3,
            "entity": "disease",
            "extractor": "ner_mitie",
            "start": 1,
            "value": "发烧"
        }
    ],
    "intent": {
        "confidence": 0.5397186422631861,
        "name": "medical"
    },
    "intent_ranking": [
        {
            "confidence": 0.5397186422631861,
            "name": "medical"
        },
        {
            "confidence": 0.16206323981749196,
            "name": "restaurant_search"
        },
        {
            "confidence": 0.1212448457737397,
            "name": "affirm"
        },
        {
            "confidence": 0.10333600028547868,
            "name": "goodbye"
        },
        {
            "confidence": 0.07363727186010374,
            "name": "greet"
        }
    ],
    "text": "我发烧了该吃什么药？"
}
```

#### 使用Python调用rasa NLU

```
from rasa_nlu.converters import load_data
from rasa_nlu.config import RasaNLUConfig
from rasa_nlu.model import Trainer

model_directory = './models/rasa_nlu_test/model_20171013-153447'

# 训练模型
def train():
    training_data = load_data('data/examples/rasa/demo-rasa_zh.json')
    trainer = Trainer(RasaNLUConfig("sample_configs/config_jieba_mitie_sklearn.json"))
    trainer.train(training_data)
    model_directory = trainer.persist('./projects/default/')  # 返回nlu模型的储存位置

# 预测
def predict():
    from rasa_nlu.model import Metadata, Interpreter
    # 用nlu模型初始化interpreter； `model_directory`为nlu模型位置
    interpreter = Interpreter.load(model_directory, RasaNLUConfig("sample_configs/config_jieba_mitie_sklearn.json"))
    # 使用加载的interpreter处理文本
    print (interpreter.parse(u"我很好奇飞信是什么"))

# train()
predict()
```






## Rasa Core

[Rasa Core][21]是一个用来搭建对话系统的框架，具体可查看[Rasa Core官方文档][22]（似乎要科学上网才能访问）。

### 安装

推荐国内用户从豆瓣 PYPI 镜像源`https://pypi.doubanio.com/simple/`下载安装，或者直接把PYPI 源改为豆瓣镜像源，否则`pip install -r requirements.txt`可能会各种连接失败。更改pip源速度快了好多：http://blog.csdn.net/u012436149/article/details/66974668

```shell
pip install rasa_core
git clone https://github.com/RasaHQ/rasa_core.git
cd rasa_core
pip install -r requirements.txt
python setup.py install
```

运行helloworld示例来检验是否正常安装成功：

```yaml
python examples/hello_world/run.py
Bot loaded. Type hello and press enter :
hello
hey there!
```

### 定义领域、意图和动作

在Rasa_Core中，我们要手动定义机器人说和做的内容，即`actions`，比如问候对方、调用某个API、查询数据库等。
```yaml
#创建文件common_domain.yml，复制如下代码
intents:#定义意图
 - greet
 - goodbye
 - chat

entities:
 - action

templates:#表示对于相应的意图采取什么样的回复
  utter_greet:
    - "hello!"
  utter_goodbye:
    - "byebye :("
  utter_chat:
    - "It seems like funny!"

actions:#定义bot可以采取的动作
  - utter_greet
  - utter_goodbye
  - utter_chat
```

### 训练你的应答模型

有了定义好的action之后，我们要基于会话历史训练概率模型，来预测需要采取的action。训练方式有多种：

 1. 如果你有标记好的对话数据，可以直接做有监督学习（**supervised learning**）；
 2. 但大多数人没有这样的条件，因此更推荐从无到有的交互式学习（**interactive learning**）。

这里主要介绍更适用于新手的第二种：在交互学习模式下，你的chatbot每做出一个决策，你都要即时给出反馈，这有点强化学习的意思，但强化学习是在对话结束后给反馈。

当你的chatbot答错时，你需要示范给它正确答案，此时模型会立即自我更新，这样就很难“重蹈覆辙”了。当你结束交互训练时，对话数据会被记录并添加到你的训练数据中。

### 实现会话逻辑

```python
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import logging

import numpy as np

from rasa_core import utils
from rasa_core.actions.action import ACTION_LISTEN_NAME
from rasa_core.agent import Agent
from rasa_core.channels.console import ConsoleInputChannel
from rasa_core.domain import TemplateDomain
from rasa_core.interpreter import NaturalLanguageInterpreter
from rasa_core.policies import Policy
from rasa_core.tracker_store import InMemoryTrackerStore

logger = logging.getLogger(__name__)

class CommonPolicy(Policy):
    def predict_action_probabilities(self, tracker, domain):
        # type: (DialogueStateTracker, Domain) -> List[float]
    #将对应的意图与动作绑定
        responses = {
            "greet": 2,
            "goodbye": 3,
            "chat": 4,
        }

        if tracker.latest_action_name == ACTION_LISTEN_NAME:
            key = tracker.latest_message.intent["name"]
            action = responses[key] if key in responses else 4
            return utils.one_hot(action, domain.num_actions)
        else:
            return np.zeros(domain.num_actions)


class HelloInterpreter(NaturalLanguageInterpreter):
    def parse(self, message):
        # intent = "greet" if 'hello' in message else "default"
        global intent
    #进行意图识别
        if 'hello' in message:
            intent='greet'
        elif 'goodbye' in message:
            intent='goodbye'
        else:
            intent='chat'
        return {
            "text": message,
            "intent": {"name": intent, "confidence": 1.0},
            "entities": []
        }


def run_hello_world(serve_forever=True):
    default_domain = TemplateDomain.load("./common_domain.yml")#加载多个domain怎么办
    agent = Agent(default_domain,
                  policies=[CommonPolicy()],
                  interpreter=HelloInterpreter(),
                  tracker_store=InMemoryTrackerStore(default_domain))

    if serve_forever:
        # Attach the commandline input to the controller to handle all
        # incoming messages from that channel
        agent.handle_channel(ConsoleInputChannel())

    return agent


if __name__ == '__main__':
    run_hello_world()
```
### 更多

`slots`：用来跟踪上下文和多轮对话的关键信息。[slot types][23]



# Reference

 1. [浅谈垂直领域的chatbot][24]
 2. Rasa Blog: [A New Approach to Conversational Software][25]


  [1]: http://img.blog.csdn.net/20171014122725452?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYW5kcm9pZF9ydWJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast
  [2]: https://baike.baidu.com/item/%E4%BC%AA%E6%98%A5%E8%8F%9C
  [3]: http://static.zybuluo.com/sixijinling/4ikgpihwlkpxok2ermifmsnv/v2-895d6f2a684116784a2e36b53f390b4d_r.png
  [4]: https://github.com/Rowl1ng/rasa_wechat
  [5]: https://github.com/youfou/wxpy
  [6]: http://wxpy.readthedocs.io/zh/latest/index.html
  [7]: https://github.com/locoda/connector-wechat-bot
  [8]: http://wxpy.readthedocs.io/zh/latest/utils.html?highlight=%E5%9B%BE%E7%81%B5%E6%9C%BA%E5%99%A8%E4%BA%BA
  [9]: http://www.jianshu.com/p/c6067ec268e3
  [10]: https://github.com/RasaHQ/rasa_nlu
  [11]: https://github.com/RasaHQ/rasa_core
  [12]: http://rasa.ai/
  [13]: https://medium.com/rasa-blog/do-it-yourself-nlp-for-bot-developers-2e2da2817f3d
  [14]: https://github.com/RasaHQ/rasa_nlu
  [15]: https://github.com/crownpku/rasa_nlu_chi
  [16]: https://rasa-nlu.readthedocs.io/en/latest/
  [17]: http://www.crownpku.com/2017/07/27/%E7%94%A8Rasa_NLU%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AD%E6%96%87NLU%E7%B3%BB%E7%BB%9F.html
  [18]: https://wenku.baidu.com/view/f20fee92daef5ef7ba0d3cf8.html?from=search
  [19]: https://github.com/RasaHQ/rasa-nlu-trainer
  [20]: https://github.com/mit-nlp/MITIE
  [21]: https://github.com/RasaHQ/rasa_core
  [22]: https://core.rasa.ai/index.html
  [23]: https://core.rasa.ai/domains.html#slot-types
  [24]: https://zhuanlan.zhihu.com/p/29757034
  [25]: https://medium.com/rasa-blog/a-new-approach-to-conversational-software-2e64a5d05f2a